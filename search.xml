<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据类型及关键字（上）]]></title>
    <url>%2F2019%2F06%2F11%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本数据类型 数据类型可以理解为固定内存大小的别名，创建变量的模子 变量本质 范例 有符号与无符号有符号 数据类型的最高位用于表示数据的符号 最高位为1，表明这个数是负数 最高位为0，表明这个数为正数 在计算机内部用补码表示有符号数 正数的补码为正数本身 负数的补码为负数的绝对值各位取反后加1 无符号 在计算机内部用原码表示无符号数 无符号数默认为正数 无符号数没有符号位 对于固定长度的无符号数 MAX_VALUE + 1 -&gt; MIN_VALUE MIN_VALUE - 1 -&gt; MAX_VALUE signed 与 unsigned C语言中默认是有符号类型 unsigned关键字声明变量为无符号类型 C语言中只有整数类型能够声明unsigned变量 当无符号 ( unsigned ) 遇到有符号 ( signed )&emsp;当无符号数与有符号数混合计算时，会将有符号数转换为无符号数后再进行计算，结果为无符号数 错误地使用了 unsigned 浮点数内存中的浮点数&ensp;浮点数在内存的存储方式为：符号位，指数，尾数。 类型 符号位 指数 尾数 float 1位（第31位） 8位（第23-30位） 23位（第0-22位） double 1位（第63位） 11位（第52-62位） 52位（第0-51位） &emsp; float 和 double 类型的数据在计算机内部的表示法是相同的，但由于所占存储空间不同，其分别能够表示的数值范围和精度不同。 浮点数存储示例 浮点数的转换步骤 将浮点数转换成二进制 用科学计数法表示二进制浮点数 计算指数偏移后的值注意：计算指数时需要加上偏移量，而偏移量的值与类型相关. 示例：对于指数 6，偏移后的值如下： &emsp;&emsp;float: 127 + 6 -&gt; 133 &emsp;&emsp;double: 1023 + 6 -&gt; 1029 10进制浮点数的内存表示 &ensp;实数 8.25 在内存中 float 表示： 8.25 转换成二进制表示： 1000.01 -&gt; 1.00001 * (2^3) 符号位： 0 指数： 127 + 3 -&gt; 130 -&gt; 10000010 小数：00001 内存中的 8.25 的float表示： 0 10000010 00001000000000000000000 -&gt; 0x41040000 浮点类型的秘密 int 类型范围 [ -2^31, 2^31 - 1 ]，float类型范围 [ -3.4 * (10^38), 3.4 * (10^38) ] float 能表示的具体数字的个数与 int 相同，但其表示的数字之间不是连续的，存在间隙 float 只是一种近似的表示法，不能作为精确数使用 由于内存表示法相对复杂，float 的运算速度比 int 慢的多 注意：&emsp; double 与 float 具有相同的内存表示法，因此 double 也是不精确的。由于 doubl 占用的内存较多，所能表示的精度比 float 高。 属性关键字（auto、register、static）&emsp; C语言中的变量可以有自己的属性，在定义变量时可以加上“属性”关键字，用于指明变量具有有特殊意义。 auto&emsp; C 语言中局部变量的默认属性，编译器默认所有的局部变量都是 auto 的，定义的局部变量在栈上分配空间。 static&emsp; 指明变量的“静态”属性并具有“作用域限定符”的意义。 static修饰的局部变量存储在程序静态区（静态局部变量只会被初始化一次）,但作用域还是在局部，不过生命期与全局变量相同。 static的另一个意义是文件作用域标示符 static修饰的全局变量作用域只是声明的文件中 static修饰的函数作用域只是声明的文件中 static修饰前： static修饰后： register 将局部变量存储于寄存器中（从寄存器取值），只是请求寄存器变量，但不一定请求成功。 作用：用于实时系统要求高时，速度快 register变量必须是 CPU寄存器可以进接受的值 不能用&amp; 运算符获取 register 变量的地址 分支循环关键字（if、switch、do、while、for）if 语句中零值比较的注意点： bool 型变量应该直接出现于条件中，不要进行比较。（ C 语言中没有 BOOL 型变量，常用的 BOOL 型变量是编译器自制，都是使用枚举方式定义的，0 假 1 或 -1 真，而 C 语言中非 0 真 0 假） 12345678910bool b = TRUE;if(b)&#123; //statement 1&#125;else&#123; //statement 2&#125; 普通变量和 0 值或常量比较时，0 值或常量应该出现在比较符号左边（防止手误带来的漏打“=”） 123456int i = 1;if( 0 == i)&#123; //statement&#125; float 型变量不能直接进行 0 值比较，需要定义精度（计算机整型算的是离散，小数是连续的，故有误差） 1234567#define EPSINON 0.0000001float f = 0.0;if((-EPSINON &lt;= f) &amp;&amp; (f &lt;= EPSINON))&#123; //statement&#125; switch switch 语句对应单个条件多个分值的情况 case 语句中的值只能是整型或字符型，且分支必须要有 break，否则会导致分支重叠 default 语句有必要加上，以处理特殊情况 case 语句的排列顺序 按字母或数字顺序排列各条语句 正常情况放在前面，异常情况放在后面 default 语句只用于处理真正的默认情况（前面无法处理）1234567891011switch(表达式)&#123; case 常量: 代码块 break; case 常量: 代码块 break; default: 代码块 break;&#125; do, while, for do 语句先执行后判断，循环体至少执行一次 while 语句先判断后执行，循环体可能不执行 for 语句先判断后执行，相比 while 更简洁 三种循环语句使用对比（累加自然数） 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;// forint f1(int n)&#123; int ret = 0, i = 0; for(i = 1; i &lt;= n; i++) &#123; ret += i; &#125; return ret ;&#125;// whileint f2(int n)&#123; int ret = 0; while((n &gt; 0) &amp;&amp; (ret += n--)); return ret;&#125;// do - whileint f3(int n)&#123; int ret = 0; if( n &gt; 0) &#123; do&#123; ret += n--; &#125;while(n); &#125; return ret;&#125;int main()&#123; printf("%d\n", f1(-10)); printf("%d\n", f2(-10)); printf("%d\n", f3(-10)); return 0;&#125; break 和 continue 的区别 break 表示终止循环的执行(跳出块) continue 表示终止本次循环体，进入下次循环执行（只能用在循环） 1234567891011121314151617181920212223#include &lt;malloc.h&gt;int func(int n)&#123; int i = 0, ret = 0; int* p = (int*)malloc(sizeof(int) * n); // 防止内存泄漏 do&#123; if( NULL == p ) break; if( n &lt; 5 ) break; if( n &gt; 100 ) break; for(i = 0; i &lt; n ; i++) &#123; p[i] = i; printf("%d\n", p[i]); &#125; ret = 1; &#125;while(0); free(p); return ret;&#125; 问题：switch 能否使用 continue 关键字？&emsp; 不能，continue 是为循环语句设计的，与分支语句无任何关系。 goto、void、extern、sizeofgoto（跳转，禁用） 高手潜规则：禁用goto 项目经验：程序质量与goto的出现次数成反比 最后的判决：将goto打入冷宫 1234567891011121314151617#include &lt;malloc.h&gt;void func(int n)&#123; int* p = NULL; if( n &lt; 0 ) &#123; goto STATUS; //内存泄漏 &#125; P = (int*)malloc(sizeof(int) * n);STATUS： p[0] = n; free(p);&#125; void （表示无） void修饰函数返回值和参数(仅表示无) 如果函数没有返回值，那么应该将其声明为void型 如果函数没有参数，应该声明其参数为void 不存在void变量 C语言没有定义void究竟是多大内存的别名（没有void的标尺无法在内存中裁剪出void对应的变量）。 下述代码在 ASNI C 编译器中是无法通过编译，但在支持 GNU 标准的 gcc 编译器而言是合法的。 12345678#include &lt;stdio.h&gt;int main()&#123; printf("%d\n", sizeof(void)); return 0;&#125; void指针的意义： C语言规定只有相同类型的指针才可以相互赋值 void指针作为左值用于“接收”任意类型的指针 void指针作为右值赋值给其它指针时需要强制类型转换123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;void* my_memset(void* p, char v, int size)&#123; void* ret = p; char* dest = (char*)p; int i = 0; for(i = 0; i &lt; size; i++) &#123; dest[i] = v; &#125; return ret;&#125;int main()&#123; int a[5] = &#123;1, 2, 3, 4, 5&#125;; int i = 0; long l = 10000; for( i = 0; i &lt; 5; i++) &#123; printf("a[%d] = %d\n", i, a[i]); &#125; my_memset(a, 0, sizeof(a)); for( i = 0; i &lt; 5; i++) &#123; printf("aset[%d] = %d\n", i, a[i]); &#125; printf("l = %d\n", l); my_memset(&amp;l, 0, sizeof(l)); printf("lset = %d\n", l); return 0;&#125; extern（声明外部定义） extern用于声明外部定义的变量和函数&emsp; extern变量在文件的其他地方定义和分配空间 123456// s2.c int g = 100;int get_min(int a, int b)&#123; return (a &lt; b)? a : b;&#125; 12345678910111213// extern.c#include &lt;stdio.h&gt;extern int g;extern int get_min(int a, int b);int main()&#123; printf("%d\n", g); printf("%d\n", get_min(1, 5)); return 0;&#125; extern用于“告诉”编译器用C方式编译&emsp; C++编译器和一些变种C编译器默认会按“自己”的方式编译函数和变量，通过extern关键可以命令编译器“以标准C方式进行编译”。 1234567extern "C"&#123; int f(int a, int b) &#123; return a + b; &#125;&#125; sizeof（“计算”大小） sizeof 是编译器的内置指示符，不是函数 在编译过程中所有的 sizeof 将被具体的数值所替换 程序的执行过程与 sizeof 没有任何关系 sizeof 用于“计算”相应实体所占的内存大小 sizeof用于类型： sizeof(type) sizeof用于变量：sizeof(var) 或 sizeof var sizeof 的值在编译期就已经确定12345678910111213141516171819202122#include &lt;stdio.h&gt;int f()&#123; printf("\n"); return 0;&#125;int main()&#123; int var = 0; int size = sizeof(var++); printf("var = %d, size = %d\n", var, size); size = sizeof(f()); printf("size = %d\n", size); return 0;&#125;]]></content>
      <categories>
        <category>C 语言深度扩展</category>
      </categories>
  </entry>
</search>
